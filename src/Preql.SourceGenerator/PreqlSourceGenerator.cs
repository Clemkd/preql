using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace Preql.SourceGenerator
{
    /// <summary>
    /// Incremental source generator that intercepts every <c>IPreqlContext.Query&lt;…&gt;()</c>
    /// call and replaces it with a compile-time-generated stub.
    ///
    /// <para>What happens at <b>compile time</b>:</para>
    /// <list type="bullet">
    ///   <item>The interpolated-string lambda is parsed from the syntax tree.</item>
    ///   <item>Every <c>{u.Name}</c> / <c>{u}</c> hole is classified as a column ref,
    ///         table ref, or runtime parameter.</item>
    ///   <item>The generator tries to resolve the SQL dialect of the receiver
    ///         (e.g. from <c>new PreqlContext(SqlDialect.PostgreSql)</c>).
    ///         If successful, a <b>single</b> SQL string constant is embedded for that
    ///         dialect only; otherwise, pre-computed strings for all known dialects are
    ///         embedded and the correct one is selected at runtime via array index.</item>
    /// </list>
    ///
    /// <para>What happens at <b>runtime</b> (per call):</para>
    /// <list type="bullet">
    ///   <item>When the dialect is known at compile time: the pre-built
    ///         <see cref="System.FormattableString"/> is returned directly — zero allocations
    ///         (no-parameter queries) or only parameter extraction happens.</item>
    ///   <item>When the dialect is unknown: a single array-index lookup selects the
    ///         correct pre-built <see cref="System.FormattableString"/>.</item>
    /// </list>
    /// </summary>
    [Generator]
    public class PreqlSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Emit the InterceptsLocationAttribute shim once — the stable InterceptableLocation
            // form uses (int version, string data) and is not in the BCL.
            context.RegisterPostInitializationOutput(static ctx =>
                ctx.AddSource("PreqlInterceptorShim.g.cs",
                    """
                    // <auto-generated/>
                    namespace System.Runtime.CompilerServices
                    {
                        [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                        internal sealed class InterceptsLocationAttribute : global::System.Attribute
                        {
                            public InterceptsLocationAttribute(int version, string data) { }
                        }
                    }
                    """));

            var queryInvocations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsQueryInvocation(node),
                    transform: static (ctx, ct) => GetQueryInvocationInfo(ctx, ct))
                .Where(static m => m.HasValue);

            context.RegisterSourceOutput(queryInvocations, static (spc, info) =>
            {
                if (!info.HasValue) return;
                var source = GenerateInterceptor(info.Value);
                spc.AddSource($"PreqlInterceptor_{info.Value.UniqueId}.g.cs", source);
            });
        }

        // ── Syntax filter ────────────────────────────────────────────────────────

        private static bool IsQueryInvocation(SyntaxNode node)
        {
            if (!(node is InvocationExpressionSyntax inv)) return false;
            if (!(inv.Expression is MemberAccessExpressionSyntax ma)) return false;
            return ma.Name.Identifier.Text == "Query";
        }

        // ── Semantic analysis ────────────────────────────────────────────────────

        private static QueryInvocationInfo? GetQueryInvocationInfo(GeneratorSyntaxContext ctx, CancellationToken ct)
        {
            var invocation = (InvocationExpressionSyntax)ctx.Node;
            var model     = ctx.SemanticModel;

            var symbolInfo = model.GetSymbolInfo(invocation);
            if (!(symbolInfo.Symbol is IMethodSymbol method)) return null;

            // Must be IPreqlContext.Query
            if (method.Name != "Query") return null;
            var typeName = method.ContainingType.ToDisplayString();
            if (!typeName.Contains("PreqlContext") && !typeName.Contains("IPreqlContext")) return null;

            // Must have at least one generic type argument
            if (method.TypeArguments.Length == 0) return null;

            // Must have a lambda as the only argument
            if (invocation.ArgumentList.Arguments.Count != 1) return null;
            if (!(invocation.ArgumentList.Arguments[0].Expression is LambdaExpressionSyntax lambda))
                return null;

            // Extract the interpolated string from the lambda body (direct expression only)
            var interp = ExtractInterpolatedString(lambda);
            if (interp == null) return null;

            // The 'this' parameter must match the compile-time (declared) type of the receiver
            var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
            var receiverType = model.GetTypeInfo(memberAccess.Expression).Type;
            var receiverTypeName = receiverType != null
                ? "global::" + receiverType.ToDisplayString()
                : "global::Preql.IPreqlContext";

            // Use the stable InterceptableLocation API to obtain the interceptor location.
            var location = Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInterceptableLocation(model, invocation, ct);
            if (location == null) return null;

            var uniqueId = location.Data.GetHashCode().ToString("X8");

            return new QueryInvocationInfo(
                EntityTypeNames:  method.TypeArguments.Select(t => t.ToDisplayString()).ToList(),
                TableNames:       method.TypeArguments.Select(t => DeriveTableName(t)).ToList(),
                LambdaParamNames: GetParamNames(lambda),
                InterpolatedString: interp,
                ReceiverTypeName: receiverTypeName,
                InterceptorVersion: location.Version,
                InterceptorData:    location.Data,
                UniqueId:         uniqueId,
                ColumnNames:      ResolveColumnNames(interp, GetParamNames(lambda), model),
                KnownDialectIndex: TryGetDialectIndex(memberAccess, model, ct));
        }

        private static InterpolatedStringExpressionSyntax ExtractInterpolatedString(
            LambdaExpressionSyntax lambda)
        {
            // Only support direct-expression bodies (no block bodies)
            return lambda.Body as InterpolatedStringExpressionSyntax;
        }

        private static List<string> GetParamNames(LambdaExpressionSyntax lambda)
        {
            if (lambda is SimpleLambdaExpressionSyntax s)
                return new List<string> { s.Parameter.Identifier.Text };
            if (lambda is ParenthesizedLambdaExpressionSyntax p)
                return p.ParameterList.Parameters.Select(x => x.Identifier.Text).ToList();
            return new List<string>();
        }

        // ── SQL analysis ─────────────────────────────────────────────────────────

        /// <summary>
        /// Walks the interpolated string and classifies each hole as a table ref,
        /// column ref, or runtime parameter.  Returns the list of SQL code fragments
        /// and the indices (within the interpolation args) of runtime parameters.
        /// </summary>
        private static SqlAnalysis AnalyzeInterpolatedString(QueryInvocationInfo info)
        {
            var paramNames     = info.LambdaParamNames;
            var tableNames     = info.TableNames;
            var paramToTable   = new Dictionary<string, string>();
            for (int i = 0; i < paramNames.Count && i < tableNames.Count; i++)
                paramToTable[paramNames[i]] = tableNames[i];

            var parts            = new List<SqlFragment>();
            var runtimeArgIdxs   = new List<int>(); // which interpolation-arg positions are SQL params
            var accLiteral       = new StringBuilder();
            int interpArgIndex   = 0;

            void FlushLiteral()
            {
                if (accLiteral.Length == 0) return;
                parts.Add(new SqlFragment(SqlFragmentKind.Literal, accLiteral.ToString()));
                accLiteral.Clear();
            }

            foreach (var content in info.InterpolatedString.Contents)
            {
                if (content is InterpolatedStringTextSyntax textNode)
                {
                    // Use ValueText to handle raw strings, escape sequences, etc.
                    accLiteral.Append(textNode.TextToken.ValueText);
                }
                else if (content is InterpolationSyntax hole)
                {
                    var expr = hole.Expression;

                    if (expr is IdentifierNameSyntax id &&
                        paramToTable.TryGetValue(id.Identifier.Text, out var tbl))
                    {
                        // {u}  →  table ref
                        FlushLiteral();
                        parts.Add(new SqlFragment(SqlFragmentKind.Table, tbl, id.Identifier.Text));
                    }
                    else if (expr is MemberAccessExpressionSyntax ma &&
                             ma.Expression is IdentifierNameSyntax maObj &&
                             paramNames.Contains(maObj.Identifier.Text))
                    {
                        // {u.Name}  →  column ref
                        FlushLiteral();
                        var propertyName = ma.Name.Identifier.Text;
                        var key = $"{maObj.Identifier.Text}.{propertyName}";
                        var columnName = info.ColumnNames.TryGetValue(key, out var cn) ? cn : propertyName;
                        parts.Add(new SqlFragment(SqlFragmentKind.Column,
                            columnName, maObj.Identifier.Text));
                    }
                    else
                    {
                        // Everything else  →  runtime parameter
                        FlushLiteral();
                        parts.Add(new SqlFragment(SqlFragmentKind.Param,
                            runtimeArgIdxs.Count.ToString()));
                        runtimeArgIdxs.Add(interpArgIndex);
                    }

                    interpArgIndex++;
                }
            }
            FlushLiteral();

            return new SqlAnalysis(parts, runtimeArgIdxs);
        }

        // ── Code generation ───────────────────────────────────────────────────────

        // Indices matching the Preql.SqlDialect enum values (must stay in sync).
        private const int DialectPostgreSql    = 0;
        private const int DialectSqlServer     = 1;
        private const int DialectMySql         = 2;
        private const int DialectSqlite        = 3;
        // Number of values in the Preql.SqlDialect enum; update this if new dialects are added.
        private const int SqlDialectCount      = 4;
        // Default fallback for unknown/out-of-range dialect values (uses bracket quoting like SQL Server).
        private const int DefaultDialectIndex  = DialectSqlServer;

        private static string GenerateInterceptor(QueryInvocationInfo info)
        {
            var analysis  = AnalyzeInterpolatedString(info);
            int typeCount = info.EntityTypeNames.Count;
            bool hasParams = analysis.RuntimeArgIndices.Count > 0;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// SQL structure and dialect quoting fully determined at compile time.");
            sb.AppendLine("// At runtime: only parameter value extraction + FormattableString creation.");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Linq.Expressions;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Preql.Generated;");
            sb.AppendLine();
            sb.AppendLine($"file static class PreqlInterceptor_{info.UniqueId}");
            sb.AppendLine("{");

            // ── Method signature ─────────────────────────────────────────────────
            var typeParams  = string.Join(", ", Enumerable.Range(1, typeCount).Select(i => $"T{i}"));
            var funcTypes   = string.Join(", ", Enumerable.Range(1, typeCount)
                                .Select(i => $"T{i}").Append("global::System.FormattableString"));
            var constraints = string.Join(" ", Enumerable.Range(1, typeCount)
                                .Select(i => $"where T{i} : class"));
            var lambdaParam = hasParams ? "queryExpression" : "_";

            if (info.KnownDialectIndex.HasValue)
            {
                // ── Dialect resolved at compile time: single SQL constant ─────────
                // Only compute (and embed) the format string for the one known dialect.
                var formatString = ComputeFormatString(analysis.Parts, info.KnownDialectIndex.Value);

                if (!hasParams)
                {
                    // Pre-built FormattableString as a static field — return it directly.
                    sb.AppendLine($"    private static readonly global::System.FormattableString __result =");
                    sb.AppendLine($"        FormattableStringFactory.Create(@\"{EscapeVerbatim(formatString)}\");");
                }
                else
                {
                    // Single format string constant — no runtime string building needed.
                    sb.AppendLine($"    private static readonly string __format =");
                    sb.AppendLine($"        @\"{EscapeVerbatim(formatString)}\";");
                }
                sb.AppendLine();

                sb.AppendLine($"    [InterceptsLocation({info.InterceptorVersion}, \"{EscapeString(info.InterceptorData)}\")]");
                sb.AppendLine($"    public static global::System.FormattableString Query{info.UniqueId}<{typeParams}>(");
                sb.AppendLine($"        this {info.ReceiverTypeName} context,");
                sb.AppendLine($"        Expression<Func<{funcTypes}>> {lambdaParam})");
                sb.AppendLine($"        {constraints}");
                sb.AppendLine("    {");

                if (!hasParams)
                {
                    sb.AppendLine("        return __result;");
                }
                else
                {
                    sb.AppendLine("        var __call = (MethodCallExpression)queryExpression.Body;");
                    for (int i = 0; i < analysis.RuntimeArgIndices.Count; i++)
                    {
                        int argIdx = analysis.RuntimeArgIndices[i];
                        sb.AppendLine($"        var __p{i} = global::Preql.SqlIdentifierHelper.EvalParamArg(__call, {argIdx});");
                    }
                    var paramArray = string.Join(", ", Enumerable.Range(0, analysis.RuntimeArgIndices.Count)
                                        .Select(i => $"__p{i}"));
                    sb.AppendLine($"        return FormattableStringFactory.Create(__format, {paramArray});");
                }
            }
            else
            {
                // ── Dialect unknown: embed all dialect variants, select at runtime ─
                var formatStrings = new string[SqlDialectCount];
                for (int d = 0; d < SqlDialectCount; d++)
                    formatStrings[d] = ComputeFormatString(analysis.Parts, d);

                if (!hasParams)
                {
                    sb.AppendLine("    private static readonly global::System.FormattableString[] __cache =");
                    sb.AppendLine("    {");
                    for (int d = 0; d < SqlDialectCount; d++)
                    {
                        var comma = d < SqlDialectCount - 1 ? "," : "";
                        sb.AppendLine($"        FormattableStringFactory.Create(@\"{EscapeVerbatim(formatStrings[d])}\"){comma}");
                    }
                    sb.AppendLine("    };");
                }
                else
                {
                    sb.AppendLine("    private static readonly string[] __formats =");
                    sb.AppendLine("    {");
                    for (int d = 0; d < SqlDialectCount; d++)
                    {
                        var comma = d < SqlDialectCount - 1 ? "," : "";
                        sb.AppendLine($"        @\"{EscapeVerbatim(formatStrings[d])}\"{comma}");
                    }
                    sb.AppendLine("    };");
                }
                sb.AppendLine();

                sb.AppendLine($"    [InterceptsLocation({info.InterceptorVersion}, \"{EscapeString(info.InterceptorData)}\")]");
                sb.AppendLine($"    public static global::System.FormattableString Query{info.UniqueId}<{typeParams}>(");
                sb.AppendLine($"        this {info.ReceiverTypeName} context,");
                sb.AppendLine($"        Expression<Func<{funcTypes}>> {lambdaParam})");
                sb.AppendLine($"        {constraints}");
                sb.AppendLine("    {");

                if (!hasParams)
                {
                    sb.AppendLine("        var __di = (int)context.Dialect;");
                    sb.AppendLine($"        return (uint)__di < (uint)__cache.Length ? __cache[__di] : __cache[{DefaultDialectIndex}];");
                }
                else
                {
                    sb.AppendLine("        var __di = (int)context.Dialect;");
                    sb.AppendLine($"        var __format = (uint)__di < (uint)__formats.Length ? __formats[__di] : __formats[{DefaultDialectIndex}];");
                    sb.AppendLine("        var __call = (MethodCallExpression)queryExpression.Body;");
                    for (int i = 0; i < analysis.RuntimeArgIndices.Count; i++)
                    {
                        int argIdx = analysis.RuntimeArgIndices[i];
                        sb.AppendLine($"        var __p{i} = global::Preql.SqlIdentifierHelper.EvalParamArg(__call, {argIdx});");
                    }
                    var paramArray = string.Join(", ", Enumerable.Range(0, analysis.RuntimeArgIndices.Count)
                                        .Select(i => $"__p{i}"));
                    sb.AppendLine($"        return FormattableStringFactory.Create(__format, {paramArray});");
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        /// <summary>
        /// Pre-computes the complete SQL format string (with <c>{n}</c> positional placeholders
        /// for runtime parameters) for the given dialect index at code-generation time.
        /// Replicates the <c>SqlIdentifierHelper.Col</c> / <c>Table</c> / <c>Quote</c> logic so
        /// that no quoting work is left for the generated runtime code.
        /// </summary>
        private static string ComputeFormatString(List<SqlFragment> parts, int dialectIndex)
        {
            var sb = new StringBuilder();
            foreach (var p in MergeLiterals(parts))
            {
                switch (p.Kind)
                {
                    case SqlFragmentKind.Literal:
                        // Escape { and } so they are treated as literals in a FormattableString format.
                        foreach (char c in p.Value)
                        {
                            if (c == '{') sb.Append("{{");
                            else if (c == '}') sb.Append("}}");
                            else sb.Append(c);
                        }
                        break;
                    case SqlFragmentKind.Column:
                        // Mirrors SqlIdentifierHelper.Col(dialect, alias, name)
                        if (!string.IsNullOrEmpty(p.TableAlias))
                        {
                            sb.Append(p.TableAlias);
                            sb.Append('.');
                        }
                        sb.Append(QuoteIdentifierCompileTime(p.Value, dialectIndex));
                        break;
                    case SqlFragmentKind.Table:
                        // Mirrors SqlIdentifierHelper.Table(dialect, tableName, alias)
                        sb.Append(QuoteIdentifierCompileTime(p.Value, dialectIndex));
                        if (!string.IsNullOrEmpty(p.TableAlias))
                        {
                            sb.Append(' ');
                            sb.Append(p.TableAlias);
                        }
                        break;
                    case SqlFragmentKind.Param:
                        sb.Append('{');
                        sb.Append(p.Value);
                        sb.Append('}');
                        break;
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Returns the dialect-quoted form of <paramref name="identifier"/> using the same
        /// rules as <c>SqlIdentifierHelper.Quote</c> (called at code-generation time).
        /// </summary>
        private static string QuoteIdentifierCompileTime(string identifier, int dialectIndex) =>
            dialectIndex switch
            {
                DialectPostgreSql => $"\"{identifier}\"",
                DialectSqlServer  => $"[{identifier}]",
                DialectMySql      => $"`{identifier}`",
                DialectSqlite     => $"\"{identifier}\"",
                _                 => $"[{identifier}]"
            };

        private static List<SqlFragment> MergeLiterals(List<SqlFragment> parts)
        {
            var result = new List<SqlFragment>();
            foreach (var p in parts)
            {
                if (p.Kind == SqlFragmentKind.Literal &&
                    result.Count > 0 &&
                    result[result.Count - 1].Kind == SqlFragmentKind.Literal)
                {
                    var prev = result[result.Count - 1];
                    result[result.Count - 1] = new SqlFragment(SqlFragmentKind.Literal,
                        prev.Value + p.Value);
                }
                else
                {
                    result.Add(p);
                }
            }
            return result.Count > 0 ? result : new List<SqlFragment> { new SqlFragment(SqlFragmentKind.Literal, "") };
        }

        // ── Helpers ───────────────────────────────────────────────────────────────

        /// <summary>
        /// Walks the interpolated string holes and resolves the SQL column name for each
        /// "param.Property" reference.  Uses the [Column("...")] attribute when present;
        /// falls back to the property name (case-sensitive).
        /// </summary>
        private static IReadOnlyDictionary<string, string> ResolveColumnNames(
            InterpolatedStringExpressionSyntax interp,
            List<string> paramNames,
            SemanticModel model)
        {
            var map = new Dictionary<string, string>();
            foreach (var content in interp.Contents)
            {
                if (!(content is InterpolationSyntax hole)) continue;
                if (!(hole.Expression is MemberAccessExpressionSyntax ma)) continue;
                if (!(ma.Expression is IdentifierNameSyntax maObj)) continue;
                if (!paramNames.Contains(maObj.Identifier.Text)) continue;

                var key = $"{maObj.Identifier.Text}.{ma.Name.Identifier.Text}";
                if (map.ContainsKey(key)) continue;

                var symbolInfo = model.GetSymbolInfo(ma);
                if (symbolInfo.Symbol is IPropertySymbol prop)
                {
                    var colAttr = prop.GetAttributes()
                        .FirstOrDefault(a => a.AttributeClass?.Name == "ColumnAttribute");
                    var colName = colAttr != null && !colAttr.ConstructorArguments.IsEmpty
                        ? colAttr.ConstructorArguments[0].Value as string
                        : null;
                    map[key] = colName ?? ma.Name.Identifier.Text;
                }
                else
                {
                    map[key] = ma.Name.Identifier.Text;
                }
            }
            return map;
        }

        private static string DeriveTableName(ITypeSymbol typeSymbol)
        {
            // Check for [Table("...")] attribute first
            foreach (var attr in typeSymbol.GetAttributes())
            {
                var attrClass = attr.AttributeClass;
                if (attrClass == null) continue;
                var attrName = attrClass.ToDisplayString();
                if (attrName == "Preql.TableAttribute" || attrName == "TableAttribute")
                {
                    if (attr.ConstructorArguments.Length > 0 &&
                        attr.ConstructorArguments[0].Value is string tableName &&
                        !string.IsNullOrEmpty(tableName))
                        return tableName;
                }
            }
            // Fall back to the type name (case-sensitive), without pluralization
            var name = typeSymbol.Name;
            if (name.Contains('<')) name = name.Substring(0, name.IndexOf('<'));
            return name;
        }

        private static string EscapeVerbatim(string s) => s.Replace("\"", "\"\"");
        private static string EscapeString(string s)   => s.Replace("\\", "\\\\").Replace("\"", "\\\"");

        // ── Dialect detection ─────────────────────────────────────────────────────

        /// <summary>
        /// Tries to resolve the <c>SqlDialect</c> of the <c>context</c> receiver at
        /// compile time.  Returns the dialect index (matching the <c>SqlDialect</c> enum)
        /// when it can be determined, or <c>null</c> when the dialect is not statically known.
        /// </summary>
        private static int? TryGetDialectIndex(
            MemberAccessExpressionSyntax memberAccess,
            SemanticModel model,
            CancellationToken ct)
            => TryExtractDialectFromExpression(memberAccess.Expression, model, ct);

        private static int? TryExtractDialectFromExpression(
            ExpressionSyntax expr,
            SemanticModel model,
            CancellationToken ct)
        {
            // Case 1: direct inline construction — new PreqlContext(SqlDialect.X).Query<T>(...)
            if (expr is ObjectCreationExpressionSyntax creation)
                return ExtractDialectFromObjectCreation(creation, model, ct);

            // Case 2: local variable — var ctx = new PreqlContext(SqlDialect.X); ctx.Query<T>(...)
            // Case 3: field with initializer — PreqlContext _ctx = new PreqlContext(SqlDialect.X)
            if (expr is IdentifierNameSyntax id)
            {
                var symbol = model.GetSymbolInfo(id, ct).Symbol;
                if (symbol is ILocalSymbol || symbol is IFieldSymbol)
                {
                    foreach (var syntaxRef in symbol.DeclaringSyntaxReferences)
                    {
                        ct.ThrowIfCancellationRequested();
                        var declNode = syntaxRef.GetSyntax(ct);
                        if (declNode is VariableDeclaratorSyntax vd && vd.Initializer?.Value != null)
                            return TryExtractDialectFromExpression(vd.Initializer.Value, model, ct);
                    }
                }
            }

            return null;
        }

        private static int? ExtractDialectFromObjectCreation(
            ObjectCreationExpressionSyntax creation,
            SemanticModel model,
            CancellationToken ct)
        {
            var ctorSymbol = model.GetSymbolInfo(creation, ct).Symbol as IMethodSymbol;
            if (ctorSymbol?.ContainingType?.Name != "PreqlContext") return null;

            var firstArg = creation.ArgumentList?.Arguments.FirstOrDefault()?.Expression;
            if (firstArg == null) return null;

            // The argument should be a member access like SqlDialect.PostgreSql
            if (firstArg is not MemberAccessExpressionSyntax dialectMember) return null;

            var fieldSymbol = model.GetSymbolInfo(dialectMember, ct).Symbol as IFieldSymbol;
            if (fieldSymbol?.ContainingType?.Name != "SqlDialect") return null;

            return fieldSymbol.Name switch
            {
                "PostgreSql" => DialectPostgreSql,
                "SqlServer"  => DialectSqlServer,
                "MySql"      => DialectMySql,
                "Sqlite"     => DialectSqlite,
                _            => (int?)null
            };
        }
    }

    // ── Data types ────────────────────────────────────────────────────────────────

    internal enum SqlFragmentKind { Literal, Column, Table, Param }

    internal readonly struct SqlFragment
    {
        // For Column: Value = columnName, TableAlias = paramName (the alias)
        // For Table:  Value = tableName,  TableAlias = paramName (the alias)
        // For Param:  Value = sqlParamIndex (e.g. "0")
        // For Literal: Value = text
        public SqlFragmentKind Kind       { get; }
        public string          Value      { get; }
        public string          TableAlias { get; }

        public SqlFragment(SqlFragmentKind kind, string value, string tableAlias = "")
        {
            Kind       = kind;
            Value      = value;
            TableAlias = tableAlias;
        }
    }

    internal readonly struct SqlAnalysis
    {
        public List<SqlFragment> Parts             { get; }
        public List<int>         RuntimeArgIndices { get; }
        public SqlAnalysis(List<SqlFragment> parts, List<int> runtimeArgIndices)
        {
            Parts             = parts;
            RuntimeArgIndices = runtimeArgIndices;
        }
    }

    internal readonly struct QueryInvocationInfo
    {
        public List<string>                       EntityTypeNames    { get; }
        public List<string>                       TableNames         { get; }
        public List<string>                       LambdaParamNames   { get; }
        public InterpolatedStringExpressionSyntax InterpolatedString { get; }
        public string ReceiverTypeName    { get; }
        public int    InterceptorVersion  { get; }
        public string InterceptorData     { get; }
        public string UniqueId  { get; }
        /// <summary>
        /// Maps "paramAlias.PropertyName" → resolved SQL column name (from [Column] attribute
        /// or the property name as fallback).
        /// </summary>
        public IReadOnlyDictionary<string, string> ColumnNames { get; }
        /// <summary>
        /// The dialect index (matching <c>SqlDialect</c> enum values) when it can be
        /// determined at compile time from the receiver expression; otherwise <c>null</c>.
        /// </summary>
        public int? KnownDialectIndex { get; }

        public QueryInvocationInfo(
            List<string>                       EntityTypeNames,
            List<string>                       TableNames,
            List<string>                       LambdaParamNames,
            InterpolatedStringExpressionSyntax InterpolatedString,
            string ReceiverTypeName,
            int InterceptorVersion, string InterceptorData, string UniqueId,
            IReadOnlyDictionary<string, string> ColumnNames,
            int? KnownDialectIndex = null)
        {
            this.EntityTypeNames    = EntityTypeNames;
            this.TableNames         = TableNames;
            this.LambdaParamNames   = LambdaParamNames;
            this.InterpolatedString = InterpolatedString;
            this.ReceiverTypeName   = ReceiverTypeName;
            this.InterceptorVersion = InterceptorVersion;
            this.InterceptorData    = InterceptorData;
            this.UniqueId  = UniqueId;
            this.ColumnNames = ColumnNames;
            this.KnownDialectIndex = KnownDialectIndex;
        }
    }
}
