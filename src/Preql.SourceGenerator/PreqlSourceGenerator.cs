using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace Preql.SourceGenerator
{
    /// <summary>
    /// Incremental source generator that intercepts every <c>IPreqlContext.Query&lt;…&gt;()</c>
    /// call and replaces it with a compile-time-generated stub.
    ///
    /// <para>What happens at <b>compile time</b>:</para>
    /// <list type="bullet">
    ///   <item>The interpolated-string lambda is parsed from the syntax tree.</item>
    ///   <item>Every <c>{u.Name}</c> / <c>{u}</c> hole is classified as a column ref,
    ///         table ref, or runtime parameter.</item>
    ///   <item>An interceptor method is emitted that rebuilds the SQL at runtime using
    ///         only simple string-concat + dialect quoting — no expression-tree walking.</item>
    /// </list>
    ///
    /// <para>What happens at <b>runtime</b> (per call):</para>
    /// <list type="bullet">
    ///   <item>Dialect-specific quoting is applied to pre-known identifiers (fast).</item>
    ///   <item>Only the parameter-value expressions are compiled/evaluated.</item>
    /// </list>
    /// </summary>
    [Generator]
    public class PreqlSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Emit the InterceptsLocationAttribute shim once — the stable InterceptableLocation
            // form uses (int version, string data) and is not in the BCL.
            context.RegisterPostInitializationOutput(static ctx =>
                ctx.AddSource("PreqlInterceptorShim.g.cs",
                    """
                    // <auto-generated/>
                    namespace System.Runtime.CompilerServices
                    {
                        [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                        internal sealed class InterceptsLocationAttribute : global::System.Attribute
                        {
                            public InterceptsLocationAttribute(int version, string data) { }
                        }
                    }
                    """));

            var queryInvocations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsQueryInvocation(node),
                    transform: static (ctx, ct) => GetQueryInvocationInfo(ctx, ct))
                .Where(static m => m.HasValue);

            context.RegisterSourceOutput(queryInvocations, static (spc, info) =>
            {
                if (!info.HasValue) return;
                var source = GenerateInterceptor(info.Value);
                spc.AddSource($"PreqlInterceptor_{info.Value.UniqueId}.g.cs", source);
            });
        }

        // ── Syntax filter ────────────────────────────────────────────────────────

        private static bool IsQueryInvocation(SyntaxNode node)
        {
            if (!(node is InvocationExpressionSyntax inv)) return false;
            if (!(inv.Expression is MemberAccessExpressionSyntax ma)) return false;
            return ma.Name.Identifier.Text == "Query";
        }

        // ── Semantic analysis ────────────────────────────────────────────────────

        private static QueryInvocationInfo? GetQueryInvocationInfo(GeneratorSyntaxContext ctx, CancellationToken ct)
        {
            var invocation = (InvocationExpressionSyntax)ctx.Node;
            var model     = ctx.SemanticModel;

            var symbolInfo = model.GetSymbolInfo(invocation);
            if (!(symbolInfo.Symbol is IMethodSymbol method)) return null;

            // Must be IPreqlContext.Query
            if (method.Name != "Query") return null;
            var typeName = method.ContainingType.ToDisplayString();
            if (!typeName.Contains("PreqlContext") && !typeName.Contains("IPreqlContext")) return null;

            // Must have at least one generic type argument
            if (method.TypeArguments.Length == 0) return null;

            // Must have a lambda as the only argument
            if (invocation.ArgumentList.Arguments.Count != 1) return null;
            if (!(invocation.ArgumentList.Arguments[0].Expression is LambdaExpressionSyntax lambda))
                return null;

            // Extract the interpolated string from the lambda body (direct expression only)
            var interp = ExtractInterpolatedString(lambda);
            if (interp == null) return null;

            // The 'this' parameter must match the compile-time (declared) type of the receiver
            var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
            var receiverType = model.GetTypeInfo(memberAccess.Expression).Type;
            var receiverTypeName = receiverType != null
                ? "global::" + receiverType.ToDisplayString()
                : "global::Preql.IPreqlContext";

            // Use the stable InterceptableLocation API to obtain the interceptor location.
            var location = Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetInterceptableLocation(model, invocation, ct);
            if (location == null) return null;

            var uniqueId = location.Data.GetHashCode().ToString("X8");

            return new QueryInvocationInfo(
                EntityTypeNames:  method.TypeArguments.Select(t => t.ToDisplayString()).ToList(),
                TableNames:       method.TypeArguments.Select(t => DeriveTableName(t)).ToList(),
                LambdaParamNames: GetParamNames(lambda),
                InterpolatedString: interp,
                ReceiverTypeName: receiverTypeName,
                InterceptorVersion: location.Version,
                InterceptorData:    location.Data,
                UniqueId:         uniqueId,
                ColumnNames:      ResolveColumnNames(interp, GetParamNames(lambda), model));
        }

        private static InterpolatedStringExpressionSyntax ExtractInterpolatedString(
            LambdaExpressionSyntax lambda)
        {
            // Only support direct-expression bodies (no block bodies)
            return lambda.Body as InterpolatedStringExpressionSyntax;
        }

        private static List<string> GetParamNames(LambdaExpressionSyntax lambda)
        {
            if (lambda is SimpleLambdaExpressionSyntax s)
                return new List<string> { s.Parameter.Identifier.Text };
            if (lambda is ParenthesizedLambdaExpressionSyntax p)
                return p.ParameterList.Parameters.Select(x => x.Identifier.Text).ToList();
            return new List<string>();
        }

        // ── SQL analysis ─────────────────────────────────────────────────────────

        /// <summary>
        /// Walks the interpolated string and classifies each hole as a table ref,
        /// column ref, or runtime parameter.  Returns the list of SQL code fragments
        /// and the indices (within the interpolation args) of runtime parameters.
        /// </summary>
        private static SqlAnalysis AnalyzeInterpolatedString(QueryInvocationInfo info)
        {
            var paramNames     = info.LambdaParamNames;
            var tableNames     = info.TableNames;
            var paramToTable   = new Dictionary<string, string>();
            for (int i = 0; i < paramNames.Count && i < tableNames.Count; i++)
                paramToTable[paramNames[i]] = tableNames[i];

            var parts            = new List<SqlFragment>();
            var runtimeArgIdxs   = new List<int>(); // which interpolation-arg positions are SQL params
            var accLiteral       = new StringBuilder();
            int interpArgIndex   = 0;

            void FlushLiteral()
            {
                if (accLiteral.Length == 0) return;
                parts.Add(new SqlFragment(SqlFragmentKind.Literal, accLiteral.ToString()));
                accLiteral.Clear();
            }

            foreach (var content in info.InterpolatedString.Contents)
            {
                if (content is InterpolatedStringTextSyntax textNode)
                {
                    // Use ValueText to handle raw strings, escape sequences, etc.
                    accLiteral.Append(textNode.TextToken.ValueText);
                }
                else if (content is InterpolationSyntax hole)
                {
                    var expr = hole.Expression;

                    if (expr is IdentifierNameSyntax id &&
                        paramToTable.TryGetValue(id.Identifier.Text, out var tbl))
                    {
                        // {u}  →  table ref
                        FlushLiteral();
                        parts.Add(new SqlFragment(SqlFragmentKind.Table, tbl, id.Identifier.Text));
                    }
                    else if (expr is MemberAccessExpressionSyntax ma &&
                             ma.Expression is IdentifierNameSyntax maObj &&
                             paramNames.Contains(maObj.Identifier.Text))
                    {
                        // {u.Name}  →  column ref
                        FlushLiteral();
                        var propertyName = ma.Name.Identifier.Text;
                        var key = $"{maObj.Identifier.Text}.{propertyName}";
                        var columnName = info.ColumnNames.TryGetValue(key, out var cn) ? cn : propertyName;
                        parts.Add(new SqlFragment(SqlFragmentKind.Column,
                            columnName, maObj.Identifier.Text));
                    }
                    else
                    {
                        // Everything else  →  runtime parameter
                        FlushLiteral();
                        parts.Add(new SqlFragment(SqlFragmentKind.Param,
                            runtimeArgIdxs.Count.ToString()));
                        runtimeArgIdxs.Add(interpArgIndex);
                    }

                    interpArgIndex++;
                }
            }
            FlushLiteral();

            return new SqlAnalysis(parts, runtimeArgIdxs);
        }

        // ── Code generation ───────────────────────────────────────────────────────

        private static string GenerateInterceptor(QueryInvocationInfo info)
        {
            var analysis = AnalyzeInterpolatedString(info);
            int typeCount = info.EntityTypeNames.Count;
            bool hasParams = analysis.RuntimeArgIndices.Count > 0;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// SQL structure determined at compile time; only dialect quoting + param");
            sb.AppendLine("// value extraction happen at runtime (no full expression-tree analysis).");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Linq.Expressions;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Preql.Generated;");
            sb.AppendLine();
            sb.AppendLine($"file static class PreqlInterceptor_{info.UniqueId}");
            sb.AppendLine("{");

            // ── [InterceptsLocation] attribute ───────────────────────────────────
            // Use the stable InterceptableLocation form: (int version, string data)
            sb.AppendLine($"    [InterceptsLocation({info.InterceptorVersion}, \"{EscapeString(info.InterceptorData)}\")]");

            // ── Method signature ─────────────────────────────────────────────────
            var typeParams   = string.Join(", ", Enumerable.Range(1, typeCount).Select(i => $"T{i}"));
            var funcTypes    = string.Join(", ", Enumerable.Range(1, typeCount)
                                .Select(i => $"T{i}").Append("global::System.FormattableString"));
            var constraints  = string.Join(" ", Enumerable.Range(1, typeCount)
                                .Select(i => $"where T{i} : class"));
            var lambdaParam  = hasParams ? "queryExpression" : "_";

            sb.AppendLine($"    public static global::System.FormattableString Query{info.UniqueId}<{typeParams}>(");
            sb.AppendLine($"        this {info.ReceiverTypeName} context,");
            sb.AppendLine($"        Expression<Func<{funcTypes}>> {lambdaParam})");
            sb.AppendLine($"        {constraints}");
            sb.AppendLine("    {");

            // ── Format string construction ────────────────────────────────────────
            sb.AppendLine("        var __d = context.Dialect;");
            sb.AppendLine("        var __format = string.Concat(");
            var formatLines = BuildFormatConcatLines(analysis.Parts);
            for (int i = 0; i < formatLines.Count; i++)
            {
                var comma = i < formatLines.Count - 1 ? "," : "";
                sb.AppendLine($"            {formatLines[i]}{comma}");
            }
            sb.AppendLine("        );");

            // ── Parameter extraction ──────────────────────────────────────────────
            if (hasParams)
            {
                sb.AppendLine("        var __call = (MethodCallExpression)queryExpression.Body;");
                for (int i = 0; i < analysis.RuntimeArgIndices.Count; i++)
                {
                    int argIdx = analysis.RuntimeArgIndices[i];
                    sb.AppendLine($"        var __p{i} = global::Preql.SqlIdentifierHelper.EvalParamArg(__call, {argIdx});");
                }
                var paramArray = string.Join(", ", Enumerable.Range(0, analysis.RuntimeArgIndices.Count)
                                    .Select(i => $"__p{i}"));
                sb.AppendLine($"        return FormattableStringFactory.Create(__format, {paramArray});");
            }
            else
            {
                sb.AppendLine("        return FormattableStringFactory.Create(__format);");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static List<string> BuildFormatConcatLines(List<SqlFragment> parts)
        {
            // Merge adjacent literals, then emit code expressions for each part.
            // Literals have { and } escaped to {{ and }} for use in a FormattableString format.
            // Params use {n} positional placeholders.
            var merged = MergeLiterals(parts);
            return merged.Select(p => p.Kind switch
            {
                SqlFragmentKind.Literal => $"@\"{EscapeVerbatim(EscapeInterpolationLiteral(p.Value))}\"",
                SqlFragmentKind.Column  => $"global::Preql.SqlIdentifierHelper.Col(__d, \"{EscapeString(p.TableAlias)}\", \"{EscapeString(p.Value)}\")",
                SqlFragmentKind.Table   => $"global::Preql.SqlIdentifierHelper.Table(__d, \"{EscapeString(p.Value)}\", \"{EscapeString(p.TableAlias)}\")",
                SqlFragmentKind.Param   => $"\"{{{p.Value}}}\"",
                _                       => "\"\"",
            }).ToList();
        }

        private static List<SqlFragment> MergeLiterals(List<SqlFragment> parts)
        {
            var result = new List<SqlFragment>();
            foreach (var p in parts)
            {
                if (p.Kind == SqlFragmentKind.Literal &&
                    result.Count > 0 &&
                    result[result.Count - 1].Kind == SqlFragmentKind.Literal)
                {
                    var prev = result[result.Count - 1];
                    result[result.Count - 1] = new SqlFragment(SqlFragmentKind.Literal,
                        prev.Value + p.Value);
                }
                else
                {
                    result.Add(p);
                }
            }
            return result.Count > 0 ? result : new List<SqlFragment> { new SqlFragment(SqlFragmentKind.Literal, "") };
        }

        // ── Helpers ───────────────────────────────────────────────────────────────

        /// <summary>
        /// Walks the interpolated string holes and resolves the SQL column name for each
        /// "param.Property" reference.  Uses the [Column("...")] attribute when present;
        /// falls back to the property name (case-sensitive).
        /// </summary>
        private static IReadOnlyDictionary<string, string> ResolveColumnNames(
            InterpolatedStringExpressionSyntax interp,
            List<string> paramNames,
            SemanticModel model)
        {
            var map = new Dictionary<string, string>();
            foreach (var content in interp.Contents)
            {
                if (!(content is InterpolationSyntax hole)) continue;
                if (!(hole.Expression is MemberAccessExpressionSyntax ma)) continue;
                if (!(ma.Expression is IdentifierNameSyntax maObj)) continue;
                if (!paramNames.Contains(maObj.Identifier.Text)) continue;

                var key = $"{maObj.Identifier.Text}.{ma.Name.Identifier.Text}";
                if (map.ContainsKey(key)) continue;

                var symbolInfo = model.GetSymbolInfo(ma);
                if (symbolInfo.Symbol is IPropertySymbol prop)
                {
                    var colAttr = prop.GetAttributes()
                        .FirstOrDefault(a => a.AttributeClass?.Name == "ColumnAttribute");
                    var colName = colAttr != null && !colAttr.ConstructorArguments.IsEmpty
                        ? colAttr.ConstructorArguments[0].Value as string
                        : null;
                    map[key] = colName ?? ma.Name.Identifier.Text;
                }
                else
                {
                    map[key] = ma.Name.Identifier.Text;
                }
            }
            return map;
        }

        private static string DeriveTableName(ITypeSymbol typeSymbol)
        {
            // Check for [Table("...")] attribute first
            foreach (var attr in typeSymbol.GetAttributes())
            {
                var attrClass = attr.AttributeClass;
                if (attrClass == null) continue;
                var attrName = attrClass.ToDisplayString();
                if (attrName == "Preql.TableAttribute" || attrName == "TableAttribute")
                {
                    if (attr.ConstructorArguments.Length > 0 &&
                        attr.ConstructorArguments[0].Value is string tableName &&
                        !string.IsNullOrEmpty(tableName))
                        return tableName;
                }
            }
            // Fall back to the type name (case-sensitive), without pluralization
            var name = typeSymbol.Name;
            if (name.Contains('<')) name = name.Substring(0, name.IndexOf('<'));
            return name;
        }

        private static string EscapeVerbatim(string s) => s.Replace("\"", "\"\"");
        private static string EscapeString(string s)   => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
        private static string EscapeInterpolationLiteral(string s) => s.Replace("{", "{{").Replace("}", "}}");
    }

    // ── Data types ────────────────────────────────────────────────────────────────

    internal enum SqlFragmentKind { Literal, Column, Table, Param }

    internal readonly struct SqlFragment
    {
        // For Column: Value = columnName, TableAlias = paramName (the alias)
        // For Table:  Value = tableName,  TableAlias = paramName (the alias)
        // For Param:  Value = sqlParamIndex (e.g. "0")
        // For Literal: Value = text
        public SqlFragmentKind Kind       { get; }
        public string          Value      { get; }
        public string          TableAlias { get; }

        public SqlFragment(SqlFragmentKind kind, string value, string tableAlias = "")
        {
            Kind       = kind;
            Value      = value;
            TableAlias = tableAlias;
        }
    }

    internal readonly struct SqlAnalysis
    {
        public List<SqlFragment> Parts             { get; }
        public List<int>         RuntimeArgIndices { get; }
        public SqlAnalysis(List<SqlFragment> parts, List<int> runtimeArgIndices)
        {
            Parts             = parts;
            RuntimeArgIndices = runtimeArgIndices;
        }
    }

    internal readonly struct QueryInvocationInfo
    {
        public List<string>                       EntityTypeNames    { get; }
        public List<string>                       TableNames         { get; }
        public List<string>                       LambdaParamNames   { get; }
        public InterpolatedStringExpressionSyntax InterpolatedString { get; }
        public string ReceiverTypeName    { get; }
        public int    InterceptorVersion  { get; }
        public string InterceptorData     { get; }
        public string UniqueId  { get; }
        /// <summary>
        /// Maps "paramAlias.PropertyName" → resolved SQL column name (from [Column] attribute
        /// or the property name as fallback).
        /// </summary>
        public IReadOnlyDictionary<string, string> ColumnNames { get; }

        public QueryInvocationInfo(
            List<string>                       EntityTypeNames,
            List<string>                       TableNames,
            List<string>                       LambdaParamNames,
            InterpolatedStringExpressionSyntax InterpolatedString,
            string ReceiverTypeName,
            int InterceptorVersion, string InterceptorData, string UniqueId,
            IReadOnlyDictionary<string, string> ColumnNames)
        {
            this.EntityTypeNames    = EntityTypeNames;
            this.TableNames         = TableNames;
            this.LambdaParamNames   = LambdaParamNames;
            this.InterpolatedString = InterpolatedString;
            this.ReceiverTypeName   = ReceiverTypeName;
            this.InterceptorVersion = InterceptorVersion;
            this.InterceptorData    = InterceptorData;
            this.UniqueId  = UniqueId;
            this.ColumnNames = ColumnNames;
        }
    }
}
